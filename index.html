<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <title>手机 HUD 拖拽版</title>
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="theme-color" content="#000" />

    <style>
      /* CSS 变量：字号、颜色（RGB）、遮罩透明度、文字透明度 */
      :root { --fs: 12vh; --rgb: 0,255,0; --alpha: 0; --text-alpha: 1; }

      /* 基础重置 */
      * { margin: 0; padding: 0; box-sizing: border-box; }
      html, body {
        height: 100%;
        background: #000;
        color: rgba(var(--rgb), var(--text-alpha));
        overflow: hidden;
        font-family: Roboto, Helvetica, Arial, sans-serif;
      }

      /* 可拖拽通用类 */
      .draggable { position: absolute; touch-action: none; user-select: none; cursor: move; z-index: 1001; }

      /* HUD 文字样式 */
      .speed { font-size: var(--fs); font-weight: 700; letter-spacing: -0.05em; }
      .unit { font-size: calc(var(--fs) * 0.5); margin-left: 0.2em; }
      .distance { font-size: calc(var(--fs) * 0.45); }

      /* 可缩放图标容器与图片 */
      .icon-wrapper { width: 18vh; height: 18vh; display: block; overflow: hidden; }
      .icon-img { width: 100%; height: 100%; display: block; object-fit: contain; }

      /* 缩放手柄（更明显的样式） */
      .resize-handle {
        position: absolute;
        right: 8px;
        bottom: 8px;
        width: 28px;
        height: 28px;
        background: linear-gradient(135deg, rgba(255,255,255,0.18) 25%, rgba(0,0,0,0.05) 25%, rgba(255,255,255,0.18) 50%, rgba(0,0,0,0.05) 50%, rgba(255,255,255,0.18) 75%, rgba(0,0,0,0.05) 75%);
        background-size: 10px 10px;
        border-radius: 6px;
        border: 2px solid rgba(255,255,255,0.18);
        cursor: nwse-resize;
        z-index: 1002;
        box-shadow: 0 6px 18px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.05);
        touch-action: none;
        transition: transform 120ms ease, box-shadow 120ms ease;
      }
      .resize-handle:hover { transform: scale(1.08); box-shadow: 0 8px 22px rgba(0,0,0,0.7), inset 0 1px 0 rgba(255,255,255,0.08); }
      .resize-handle:active { transform: scale(0.98); }

      /* 遮罩层 */
      .dimLayer { position: fixed; inset: 0; background: #000; opacity: var(--alpha); pointer-events: none; }

      /* 控制面板 */
      .panel {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.6);
        color: #fff;
        padding: 10px 20px;
        border-radius: 8px;
        display: none;
        gap: 12px;
        align-items: center;
        font-size: 14px;
      }
      body.showPanel .panel { display: flex; }
      .panel input { width: 120px; }

      /* 示例图片：可缩放的包装器 */
      .img-wrapper { width: 140px; height: 90px; border-radius: 8px; box-shadow: 0 6px 18px rgba(0,0,0,0.6); border: 2px solid rgba(255,255,255,0.06); z-index: 90; overflow: hidden; display: block; }
      /* 将示例图片强制置于更低层，避免遮挡文字 */
      #exampleImgWrapper { z-index: 50 !important; }
      /* 元素检查器样式 */
      .inspector {
        position: fixed;
        min-width: 220px;
        background: rgba(20,20,20,0.95);
        color: #fff;
        padding: 8px;
        border-radius: 8px;
        box-shadow: 0 8px 24px rgba(0,0,0,0.6);
        z-index: 2000;
        font-size: 13px;
        display: none;
      }
      .inspector .ins-row{display:flex;align-items:center;justify-content:space-between;margin:6px 0}
      .inspector label{flex:1;margin-right:8px}
      .tint-overlay{position:absolute;inset:0;pointer-events:none;mix-blend-mode:multiply;opacity:0}
      .example-img { width: 100%; height: 100%; display: block; object-fit: cover; }

      /* HUD 容器镜像样式（翻转所有 HUD 子元素） */
      #hudRoot.mirrored { transform: scaleX(-1); transform-origin: 50% 50%; }

      /* 面板切换按钮 */
      #togglePanelBtn { position: fixed; left: 12px; bottom: 18px; padding: 8px 10px; border-radius: 6px; background: rgba(255,255,255,0.06); color: inherit; border: 1px solid rgba(255,255,255,0.06); backdrop-filter: blur(4px); z-index: 1000; }
    </style>
  </head>

  <body>
    <!-- 面板开关 -->
    <button id="togglePanelBtn">显示/隐藏</button>

    <!-- HUD 根容器（用于整体镜像翻转） -->
    <div id="hudRoot">
    <!-- ===== 可拖拽元素 ===== -->
    <div id="speed" class="draggable speed"><span id="spdVal">0</span><span class="unit">km/h</span></div>
    <div id="distance" class="draggable distance">800 m</div>

    <!-- 四个方向图标（每次仅显示一个，支持拖动与缩放） -->
    <div id="iconStraight" class="draggable icon-wrapper">
      <img class="icon-img" src="https://s41.ax1x.com/2025/12/17/pZlGuvQ.png" alt="straight">
      <div class="resize-handle"></div>
    </div>

    <div id="iconLeft" class="draggable icon-wrapper">
      <img class="icon-img" src="https://s41.ax1x.com/2025/12/17/pZlGeC8.png" alt="left">
      <div class="resize-handle"></div>
    </div>

    <div id="iconRight" class="draggable icon-wrapper">
      <img class="icon-img" src="https://s41.ax1x.com/2025/12/17/pZlGm8S.png" alt="right">
      <div class="resize-handle"></div>
    </div>

    <div id="iconUturn" class="draggable icon-wrapper">
      <img class="icon-img" src="https://s41.ax1x.com/2025/12/17/pZlGngg.png" alt="uturn">
      <div class="resize-handle"></div>
    </div>

    <!-- 亮度遮罩 -->
    <div class="dimLayer"></div>

    <!-- 示例图片：封装为可拖拽、可缩放的容器，使用本地资源 -->
    <div id="exampleImgWrapper" class="draggable img-wrapper">
      <img id="exampleImg" class="example-img" src="https://s41.ax1x.com/2025/12/17/pZlJ0SS.png" alt="示例图片">
      <div class="resize-handle"></div>
    </div>
      </div><!-- /#hudRoot -->

    <!-- 元素检查器（点击元素时显示） -->
    <div id="inspector" class="inspector" aria-hidden="true">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
        <strong id="inspectorTitle">编辑元素</strong>
        <button id="inspectorClose" style="background:transparent;border:none;color:#fff;font-size:16px;cursor:pointer">✕</button>
      </div>
      <div class="ins-row"><label>宽度 (px)</label><input id="inspWidth" type="number" style="width:80px"></div>
      <div class="ins-row"><label>高度 (px)</label><input id="inspHeight" type="number" style="width:80px"></div>
      <div class="ins-row"><label>字号 (px)</label><input id="inspFontSize" type="number" style="width:80px"></div>
      <div class="ins-row"><label>颜色</label><input id="inspColor" type="color" style="width:80px"></div>
      <div class="ins-row"><label>色度</label><input id="inspTintAlpha" type="range" min="0" max="1" step="0.01" style="width:100%"></div>
      <div class="ins-row"><label>亮度</label><input id="inspBrightness" type="range" min="0.2" max="2" step="0.01" style="width:100%"></div>
      <div class="ins-row"><label>透明度</label><input id="inspOpacity" type="range" min="0" max="1" step="0.01" style="width:100%"></div>
      <div class="ins-row"><label>图层 (z)</label><input id="inspZ" type="number" min="0" max="9999" style="width:80px"></div>
      <div style="display:flex;gap:8px;margin-top:8px"><button id="insApply" style="flex:1">应用</button><button id="insReset" style="flex:1">重置</button></div>
    </div>

      <!-- 控制面板（整体交互已注释，仅保留镜像指令） -->
      <div id="panel" class="panel draggable">
        <button id="mirrorBtn">镜像</button>
      </div>
    <script>
      /* ------------------ 配置（字号、RGB、亮度） ------------------ */
      const cfg = { fs: 12, rgb: [0,255,0], alpha: 0, mirror: false, textAlpha: 1 };
      Object.assign(cfg, JSON.parse(localStorage.getItem('hudCfg') || '{}'));

      function apply(){
        document.documentElement.style.setProperty('--fs', cfg.fs + 'vh');
        const rgbVal = Array.isArray(cfg.rgb) ? cfg.rgb.join(',') : (cfg.rgb || '0,255,0');
        document.documentElement.style.setProperty('--rgb', rgbVal);
        document.documentElement.style.setProperty('--alpha', cfg.alpha);
        document.documentElement.style.setProperty('--text-alpha', cfg.textAlpha);
        const hudRoot = document.getElementById('hudRoot');
        if (hudRoot) hudRoot.classList.toggle('mirrored', cfg.mirror);
        localStorage.setItem('hudCfg', JSON.stringify(cfg));
      }

      function clampRGB(v){ if (isNaN(v)) return 0; return Math.max(0, Math.min(255, Math.round(v))); }

      // 只保留镜像指令的绑定与配置恢复
      document.getElementById('mirrorBtn').onclick = () => { cfg.mirror = !cfg.mirror; apply(); };
      apply();

      /* ------------------ 面板显隐（按钮控制） ------------------ */
      document.getElementById('togglePanelBtn').onclick = () => {
        document.body.classList.toggle('showPanel');
      };

      /* ------------------ 元素检查器：对单个元素进行样式编辑 ------------------ */
      const stylesKey = 'hudStyles';
      const hudStyles = JSON.parse(localStorage.getItem(stylesKey) || '{}');
      let inspectorTarget = null;

      const inspector = document.getElementById('inspector');
      const inspectorTitle = document.getElementById('inspectorTitle');
      const inspWidth = document.getElementById('inspWidth');
      const inspHeight = document.getElementById('inspHeight');
      const inspFontSize = document.getElementById('inspFontSize');
      const inspColor = document.getElementById('inspColor');
      const inspTintAlpha = document.getElementById('inspTintAlpha');
      const inspBrightness = document.getElementById('inspBrightness');
      const inspOpacity = document.getElementById('inspOpacity');
      const inspZ = document.getElementById('inspZ');
      const insClose = document.getElementById('inspectorClose');
      const insApply = document.getElementById('insApply');
      const insReset = document.getElementById('insReset');

      function applySavedStyles(id, el){
        const s = hudStyles[id];
        if (!s) return;
        if (s.width) el.style.width = s.width;
        if (s.height) el.style.height = s.height;
        if (s.fontSize) el.style.fontSize = s.fontSize;
        if (s.color) {
          // 如果包含 png 图片，尽量恢复重着色图（dataUrl）或尝试 recolor
          const img = el.querySelector && el.querySelector('img');
          if (img && (s.recolored || isPngSrc(img.src) || isPngSrc(s.originalSrc || img.dataset.__origSrc))){
            if (s.recolored){ img.src = s.recolored; }
            else if (s.color){ // 尝试重新着色原图
              const orig = s.originalSrc || img.dataset.__origSrc || img.src;
              img.dataset.__origSrc = orig;
              recolorPngImage(img, s.color).then(res=>{ if(res.success) { s.recolored = res.dataUrl; localStorage.setItem(stylesKey, JSON.stringify(hudStyles)); } else ensureTint(el, s.color, s.tintAlpha || 0); });
            }
          } else {
            if (el.classList.contains('speed') || el.classList.contains('distance')) el.style.color = s.color;
            else ensureTint(el, s.color, s.tintAlpha || 0);
          }
        }
        if (s.brightness) el.style.filter = `brightness(${s.brightness})`;
        if (typeof s.opacity !== 'undefined') el.style.opacity = s.opacity;
        if (s.zIndex) el.style.zIndex = s.zIndex;
      }

      function ensureTint(el, color, alpha){
        if (!el.classList.contains('icon-wrapper')) return;
        el.style.position = el.style.position || 'absolute';
        let ov = el.querySelector('.tint-overlay');
        if (!ov){ ov = document.createElement('div'); ov.className = 'tint-overlay'; el.appendChild(ov); }
        ov.style.background = color || '#000000';
        ov.style.opacity = (typeof alpha === 'number') ? alpha : 0;
      }

      // 尝试使用 canvas 重着色 PNG（保留高光/阴影），若失败则回退到 overlay
      function isPngSrc(src){ if(!src) return false; return src.indexOf('.png') !== -1 || src.indexOf('image/png')!==-1; }

      async function recolorPngImage(imgEl, hexColor){
        try{
          const origSrc = imgEl.getAttribute('src');
          const img = new Image();
          img.crossOrigin = 'Anonymous';
          img.src = origSrc;
          await new Promise((res,rej)=>{ img.onload=res; img.onerror=()=>rej(new Error('img load error')) });
          const w = img.naturalWidth || img.width; const h = img.naturalHeight || img.height;
          const c = document.createElement('canvas'); c.width = w; c.height = h; const ctx = c.getContext('2d');
          ctx.drawImage(img,0,0,w,h);
          const data = ctx.getImageData(0,0,w,h);
          const d = data.data;
          const tr = parseInt(hexColor.slice(1,3),16);
          const tg = parseInt(hexColor.slice(3,5),16);
          const tb = parseInt(hexColor.slice(5,7),16);
          for(let i=0;i<d.length;i+=4){
            const r=d[i], g=d[i+1], b=d[i+2], a=d[i+3];
            if(a===0) continue;
            const lum = 0.299*r + 0.587*g + 0.114*b; // 灰度用于保留明暗
            d[i]   = Math.round(tr * (lum/255));
            d[i+1] = Math.round(tg * (lum/255));
            d[i+2] = Math.round(tb * (lum/255));
            // alpha 保持不变
          }
          ctx.putImageData(data,0,0);
          const url = c.toDataURL('image/png');
          // 保存原始 src 以便重置
          if(!imgEl.dataset.__origSrc) imgEl.dataset.__origSrc = origSrc;
          imgEl.src = url;
          return { success:true, dataUrl:url };
        }catch(err){
          console.warn('recolorPngImage failed, fallback to overlay', err);
          return { success:false };
        }
      }

      // 初始化：应用已保存样式
      document.querySelectorAll('.draggable').forEach(el => {
        if (hudStyles[el.id]) applySavedStyles(el.id, el);
      });

      // 点击显示检查器（点击时阻止拖拽起始冒泡）
      document.querySelectorAll('.draggable').forEach(el => {
        el.addEventListener('click', e => {
          e.stopPropagation();
          showInspectorFor(el);
        });
      });

      function showInspectorFor(el){
        inspectorTarget = el;
        inspectorTitle.textContent = el.id || el.className || '元素';
        const rect = el.getBoundingClientRect();
        inspector.style.left = Math.min(window.innerWidth - 240, rect.right + 8) + 'px';
        inspector.style.top = Math.max(8, rect.top) + 'px';
        inspector.style.display = 'block';
        inspector.setAttribute('aria-hidden','false');

        // 填充当前值
        const cs = getComputedStyle(el);
        inspWidth.value = parseInt(cs.width) || '';
        inspHeight.value = parseInt(cs.height) || '';
        inspFontSize.value = parseInt(cs.fontSize) || '';
        // color to hex
        const col = cs.color;
        inspColor.value = rgbToHex(col) || '#00ff00';
        // tint
        const ov = el.querySelector && el.querySelector('.tint-overlay');
        inspTintAlpha.value = ov ? parseFloat(ov.style.opacity || 0) : 0;
        inspBrightness.value = (el.style.filter && parseBrightness(el.style.filter)) || 1;
        inspOpacity.value = parseFloat(cs.opacity) || 1;
        inspZ.value = el.style.zIndex || parseInt(cs.zIndex) || 1001;
      }

      function hideInspector(){ inspector.style.display='none'; inspector.setAttribute('aria-hidden','true'); inspectorTarget=null; }
      insClose.addEventListener('click', hideInspector);

      function parseBrightness(filter){
        const m = /brightness\(([^)]+)\)/.exec(filter||''); return m ? parseFloat(m[1]) : 1;
      }

      function rgbToHex(rgb){
        if (!rgb) return null;
        const m = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
        if (!m) return null;
        return '#'+[1,2,3].map(i=>parseInt(m[i]).toString(16).padStart(2,'0')).join('');
      }

      // 应用按钮
      insApply.addEventListener('click', ()=>{
        if (!inspectorTarget) return;
        const el = inspectorTarget;
        const id = el.id || ('el_'+Math.random().toString(36).slice(2,8));
        const s = hudStyles[id] = hudStyles[id] || {};
        if (inspWidth.value) { el.style.width = inspWidth.value + 'px'; s.width = el.style.width; } else { el.style.width = ''; delete s.width; }
        if (inspHeight.value) { el.style.height = inspHeight.value + 'px'; s.height = el.style.height; } else { el.style.height = ''; delete s.height; }
        if (inspFontSize.value) { el.style.fontSize = inspFontSize.value + 'px'; s.fontSize = el.style.fontSize; } else { el.style.fontSize=''; delete s.fontSize; }
        if (inspColor.value){
          const img = el.querySelector && el.querySelector('img');
          const hex = inspColor.value;
          if (img && isPngSrc(img.src)){
            // 对 PNG 尝试 canvas 重着色；失败回退到 overlay
            recolorPngImage(img, hex).then(res=>{
              if (res.success){ s.recolored = res.dataUrl; s.originalSrc = img.dataset.__origSrc || img.src; s.color = hex; s.tintAlpha = parseFloat(inspTintAlpha.value); localStorage.setItem(stylesKey, JSON.stringify(hudStyles)); }
              else { ensureTint(el, hex, parseFloat(inspTintAlpha.value)); s.color = hex; s.tintAlpha = parseFloat(inspTintAlpha.value); localStorage.setItem(stylesKey, JSON.stringify(hudStyles)); }
            });
          } else if (el.classList.contains('speed') || el.classList.contains('distance')){ el.style.color = hex; s.color = hex; }
          else { ensureTint(el, hex, parseFloat(inspTintAlpha.value)); s.color = hex; s.tintAlpha = parseFloat(inspTintAlpha.value); }
        }
        if (inspBrightness.value){ el.style.filter = `brightness(${inspBrightness.value})`; s.brightness = inspBrightness.value; }
        if (inspOpacity.value){ el.style.opacity = inspOpacity.value; s.opacity = inspOpacity.value; }
        if (inspZ.value){ el.style.zIndex = inspZ.value; s.zIndex = inspZ.value; }
        localStorage.setItem(stylesKey, JSON.stringify(hudStyles));
      });

      insReset.addEventListener('click', ()=>{
        if (!inspectorTarget) return; const el=inspectorTarget; const id=el.id; if (hudStyles[id]){ delete hudStyles[id]; localStorage.setItem(stylesKey, JSON.stringify(hudStyles)); }
        // 重置并恢复 PNG 原始 src（若存在）
        el.style.width=''; el.style.height=''; el.style.fontSize=''; el.style.color=''; el.style.filter=''; el.style.opacity=''; el.style.zIndex='';
        const ov=el.querySelector&&el.querySelector('.tint-overlay'); if(ov) ov.style.opacity=0;
        const img = el.querySelector && el.querySelector('img'); if(img && img.dataset && img.dataset.__origSrc){ img.src = img.dataset.__origSrc; delete img.dataset.__origSrc; }
        hideInspector();
      });

      // 点击空白关闭检查器
      document.addEventListener('click', (e)=>{ if (inspector && !inspector.contains(e.target)) hideInspector(); });

      /* ------------------ 拖拽 / 缩放 持久化 ------------------ */
      const posKey = 'hudPos';
      const pos = JSON.parse(localStorage.getItem(posKey) || '{}');

      // 初始化位置与尺寸（如有保存值则恢复）
      function initPos(el){
        const id = el.id;
        if (pos[id]){
          el.style.left = pos[id].x; el.style.top = pos[id].y;
          if (pos[id].w) el.style.width = pos[id].w;
          if (pos[id].h) el.style.height = pos[id].h;
        } else {
          // 默认位置按 id 分布，避免堆叠
          switch(id){
            case 'iconStraight': el.style.left = '12px'; el.style.top = '12px'; break;
            case 'iconLeft': el.style.left = '12px'; el.style.top = '120px'; break;
            case 'iconRight': el.style.left = '12px'; el.style.top = '240px'; break;
            case 'iconUturn': el.style.left = '12px'; el.style.top = '360px'; break;
            case 'distance': el.style.left = '12px'; el.style.top = '8vh'; break;
            case 'speed': el.style.left = '50%'; el.style.top = '10vh'; el.style.transform = 'translateX(-50%)'; break;
            default: el.style.left = '50%'; el.style.top = '50%'; el.style.transform = 'translate(-50%,-50%)';
          }
        }
      }
      document.querySelectorAll('.draggable').forEach(initPos);

      // 通用拖拽（点击表单控件或缩放手柄时不触发）
      function dragStart(e){
        const el = e.currentTarget;
        if (e.target && e.target.closest && e.target.closest('input,button,select,textarea,label')) return;
        if (e.target && e.target.classList && e.target.classList.contains('resize-handle')) return;

        const touch = e.type.includes('touch');
        const pt = touch ? e.touches[0] : e;
        const rect = el.getBoundingClientRect();
        const offsetX = pt.clientX - rect.left;
        const offsetY = pt.clientY - rect.top;
        el.style.transform = 'none'; // 取消初始居中偏移

        function move(ev){
          const p = touch ? ev.touches[0] : ev;
          const x = p.clientX - offsetX;
          const y = p.clientY - offsetY;
          el.style.left = x + 'px';
          el.style.top = y + 'px';
        }

        function end(){
          pos[el.id] = { x: el.style.left, y: el.style.top };
          if (el.style.width) pos[el.id].w = el.style.width;
          if (el.style.height) pos[el.id].h = el.style.height;
          localStorage.setItem(posKey, JSON.stringify(pos));
          document.removeEventListener(touch ? 'touchmove' : 'mousemove', move);
          document.removeEventListener(touch ? 'touchend' : 'mouseup', end);
        }

        document.addEventListener(touch ? 'touchmove' : 'mousemove', move, { passive: true });
        document.addEventListener(touch ? 'touchend' : 'mouseup', end);
      }

      document.querySelectorAll('.draggable').forEach(el => {
        el.addEventListener('mousedown', dragStart);
        el.addEventListener('touchstart', dragStart, { passive: true });
      });

      // 缩放逻辑（右下角手柄）
      function resizeStart(e){
        e.stopPropagation();
        const handle = e.currentTarget;
        const wrapper = handle.parentElement;
        const touch = e.type.includes('touch');
        const startX = touch ? e.touches[0].clientX : e.clientX;
        const startY = touch ? e.touches[0].clientY : e.clientY;
        const rect = wrapper.getBoundingClientRect();
        const startW = rect.width;
        const startH = rect.height;

        function move(ev){
          const p = touch ? ev.touches[0] : ev;
          const dx = p.clientX - startX;
          const dy = p.clientY - startY;
          const newW = Math.max(24, Math.round(startW + dx));
          const newH = Math.max(24, Math.round(startH + dy));
          wrapper.style.width = newW + 'px';
          wrapper.style.height = newH + 'px';
        }

        function end(){
          pos[wrapper.id] = pos[wrapper.id] || {};
          pos[wrapper.id].w = wrapper.style.width;
          pos[wrapper.id].h = wrapper.style.height;
          localStorage.setItem(posKey, JSON.stringify(pos));
          document.removeEventListener(touch ? 'touchmove' : 'mousemove', move);
          document.removeEventListener(touch ? 'touchend' : 'mouseup', end);
        }

        document.addEventListener(touch ? 'touchmove' : 'mousemove', move, { passive: true });
        document.addEventListener(touch ? 'touchend' : 'mouseup', end);
      }

      document.querySelectorAll('.resize-handle').forEach(h => {
        h.addEventListener('mousedown', resizeStart);
        h.addEventListener('touchstart', resizeStart, { passive: true });
      });

      /* ------------------ 图标切换（5s 随机切换，位置保持） ------------------ */
      const icons = ['iconStraight','iconLeft','iconRight','iconUturn'];
      let activeIcon = icons[Math.floor(Math.random() * icons.length)];

      function showActive(id){
        icons.forEach(i => {
          const el = document.getElementById(i);
          if (!el) return;
          el.style.display = (i === id) ? 'block' : 'none';
        });
      }

      function switchIcon(nextId){
        if (nextId === activeIcon) return;
        const prevEl = document.getElementById(activeIcon);
        const nextEl = document.getElementById(nextId);
        if (prevEl && nextEl){
          // 将下一个图标的位置设置为上一个图标当前的位置
          nextEl.style.left = prevEl.style.left;
          nextEl.style.top  = prevEl.style.top;
          pos[nextId] = pos[nextId] || {};
          pos[nextId].x = nextEl.style.left;
          pos[nextId].y = nextEl.style.top;
          // 拷贝尺寸（若存在）
          if (pos[activeIcon] && (pos[activeIcon].w || pos[activeIcon].h)){
            if (pos[activeIcon].w) nextEl.style.width  = pos[activeIcon].w, pos[nextId].w = pos[activeIcon].w;
            if (pos[activeIcon].h) nextEl.style.height = pos[activeIcon].h, pos[nextId].h = pos[activeIcon].h;
          }
          localStorage.setItem(posKey, JSON.stringify(pos));
        }
        activeIcon = nextId;
        showActive(activeIcon);
      }

      // 初始只显示一个并开始定时切换
      showActive(activeIcon);
      setInterval(()=>{
        const candidates = icons.filter(i => i !== activeIcon);
        const next = candidates[Math.floor(Math.random() * candidates.length)];
        switchIcon(next);
      }, 5000);

      /* ------------------ 假数据（速度在 80-120 随机变化） ------------------ */
      setInterval(()=>{
        const speed = Math.floor(Math.random() * (120 - 80 + 1)) + 80;
        document.getElementById('spdVal').textContent = speed;
      }, 300);

      let dist = 800;
      setInterval(()=>{
        dist -= 8; if (dist <= 0) dist = 800;
        document.getElementById('distance').textContent = dist + ' m';
      }, 500);
    </script>
  </body>
</html>